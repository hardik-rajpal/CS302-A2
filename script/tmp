diff --git a/.vscode/launch.json b/.vscode/launch.json
index c3ae5d0..83428ba 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -34,7 +34,7 @@
             "program": "${workspaceRoot}/iplC",
             "cwd": "${workspaceFolder}",
             "args": [
-                "testcases/test-kanishka.c",
+                "main.c",
                 ">",
                 "myout.json",
                 "2>mydebug.txt"
diff --git a/ast.cpp b/ast.cpp
index f40026d..8630ef3 100644
--- a/ast.cpp
+++ b/ast.cpp
@@ -4,7 +4,7 @@
 #include "ast.hh"
 #include "util.hh"
 typespec_astnode typespec_astnode::voidc,typespec_astnode::intc,typespec_astnode::floatc,typespec_astnode::stringc,typespec_astnode::structc;
-std::set<std::string> op_binary_astnode::boolops,op_binary_astnode::boolgens;
+std::set<std::string> op_binary_astnode::boolops,op_binary_astnode::boolgens,op_binary_astnode::boolgenseq;
 identifier_astnode::identifier_astnode(std::string id) : id(id) { }
 
 void identifier_astnode::print() {
@@ -152,7 +152,7 @@ void op_binary_astnode::print() {
     );
 }
 bool typespec_astnode::comparableTypes(typespec_astnode t2){
-    if(compatibleWith(t2)){
+    if(isNumeric()&&(t2.isNumeric())){
         return true;
     }
     int nrs = numptrstars+arrsizes.size();
@@ -162,12 +162,35 @@ bool typespec_astnode::comparableTypes(typespec_astnode t2){
     }
     return false;
 }
+bool typespec_astnode::equatableTypes(typespec_astnode t2){
+    if(comparableTypes(t2)){
+        return true;
+    }
+    if(typeName=="void*"||t2.typeName=="void*"){
+        return true;
+    }
+    if(isnullval&&(t2.numptrstars+t2.arrsizes.size()>0)){
+        return true;
+    }
+    if(t2.isnullval&&(numptrstars+arrsizes.size()>0)){
+        return true;
+    }
+    return false;
+}
 bool op_binary_astnode::operandsCompatible(std::string op,exp_astnode* exp1, exp_astnode* exp2){
-    if(op_binary_astnode::boolgens.count(op)){
+    if(op_binary_astnode::boolgenseq.count(op)){
+        return exp1->typeNode.equatableTypes(exp2->typeNode);
+    }
+    else if(op_binary_astnode::boolgens.count(op)){
         return exp1->typeNode.comparableTypes(exp2->typeNode);
     }
     else if(op_binary_astnode::boolops.count(op)){
-        return true;
+        if(exp1->typeNode.isNumeric()||(exp1->typeNode.numptrstars+exp1->typeNode.arrsizes.size()>0)){
+            if(exp2->typeNode.isNumeric()||(exp2->typeNode.numptrstars+exp2->typeNode.arrsizes.size()>0)){
+                return true;
+            }
+        }
+        return false;
     }
     else{
         //numeric ops TODO
@@ -189,6 +212,7 @@ bool op_binary_astnode::operandsCompatible(std::string op,exp_astnode* exp1, exp
                     return true;
                 }
             }
+            return false;
         }
         return false;
     }
@@ -204,6 +228,12 @@ bool op_unary_astnode::compatibleOperand(std::string op, exp_astnode* exp){
         }
         return false;
     }
+    if(op=="UMINUS"&&(!exp->typeNode.isNumeric())){
+        return false;
+    }
+    if(op=="NOT"&&(!exp->typeNode.isNumeric())&&(nrs==0)){
+        return false;
+    }
     return true;
 }
 op_unary_astnode::op_unary_astnode(std::string op, exp_astnode* exp): op(op), exp(exp) {
@@ -337,15 +367,21 @@ void typespec_astnode::deref(){
         //nothing done=> typeName unchanged=> error check in parser.yy
         return;
     }
+    islval = true;
     typeName = genTypeName();
 }
 void typespec_astnode::addressOf(){
     numptrstars+=1;
+    islval = false;
     typeName = genTypeName();
 }
 bool typespec_astnode::isNumeric(){
     return numtypes.count(typeName);
 }
+int typespec_astnode::getnrs(){
+    return numptrstars+arrsizes.size();
+}
+
 std::string typespec_astnode::genTypeName(){
     std::string tn = baseTypeName;
     int k = numptrstars;
diff --git a/ast.hh b/ast.hh
index e7899d0..394f0ca 100644
--- a/ast.hh
+++ b/ast.hh
@@ -42,7 +42,9 @@ public:
     void addressOf();
     bool compatibleWith(typespec_astnode t2, bool isparam=false);
     bool comparableTypes(typespec_astnode t2);
+    bool equatableTypes(typespec_astnode t2);
     bool isNumeric();
+    int getnrs();
     int genTypeWidth();
     
 };
@@ -123,6 +125,7 @@ private:
 public:
     static std::set<std::string> boolops;
     static std::set<std::string> boolgens;
+    static std::set<std::string> boolgenseq;
 public:
     op_binary_astnode(std::string, exp_astnode*, exp_astnode*);
     void print();
diff --git a/ast.o b/ast.o
index e21ccec..9650ed1 100644
Binary files a/ast.o and b/ast.o differ
diff --git a/iplC b/iplC
index fadef53..0bbfb9f 100755
Binary files a/iplC and b/iplC differ
diff --git a/main.c b/main.c
index 9317dbb..e343662 100644
--- a/main.c
+++ b/main.c
@@ -1,5 +1,11 @@
+float dod(){
+    int i;
+    return i;
+}
+struct x{
+    int i;
+};
 int main(){
-    int a;
-    a = "abc"+1;
-    printf("bleh %d",1);
+    int ***b;
+    int **b;
 }
\ No newline at end of file
diff --git a/myout.json b/myout.json
index 25c8db5..120419e 100644
--- a/myout.json
+++ b/myout.json
@@ -1 +1,88 @@
-Error at line 3: Incompatible operands for PLUS?: "string", "int"
+{
+    "globalST": [
+        [
+            "dod",
+            "fun",
+            "global",
+            0,
+            0,
+            "float"
+        ],
+        [
+            "main",
+            "fun",
+            "global",
+            0,
+            0,
+            "int"
+        ],
+        [
+            "struct x",
+            "struct",
+            "global",
+            4,
+            "-",
+            "-"
+        ]
+    ],
+    "structs": [
+        {
+            "name": "struct x",
+            "localST": [
+                [
+                    "i",
+                    "var",
+                    "local",
+                    4,
+                    0,
+                    "int"
+                ]
+            ]
+        }
+    ],
+    "functions": [
+        {
+            "name": "dod",
+            "localST": [
+                [
+                    "i",
+                    "var",
+                    "local",
+                    4,
+                    -4,
+                    "int"
+                ]
+            ],
+            "ast": {
+                "seq": [
+                    {
+                        "return": {
+                            "op_unary": {
+                                "op": "TO_FLOAT",
+                                "child": {
+                                    "identifier": "i"
+                                }
+                            }
+                        }
+                    }
+                ]
+            }
+        },
+        {
+            "name": "main",
+            "localST": [
+                [
+                    "b",
+                    "var",
+                    "local",
+                    4,
+                    -8,
+                    "int**"
+                ]
+            ],
+            "ast": {
+                "seq": []
+            }
+        }
+    ]
+}
\ No newline at end of file
diff --git a/parser.o b/parser.o
index 48a2e97..6f86f85 100644
Binary files a/parser.o and b/parser.o differ
diff --git a/parser.tab.cc b/parser.tab.cc
index a1ab673..39c023a 100644
--- a/parser.tab.cc
+++ b/parser.tab.cc
@@ -1884,7 +1884,7 @@ namespace IPL {
         if((yystack_[2].value.as < exp_astnode* > ()->typeNode.compatibleWith(yystack_[0].value.as < exp_astnode* > ()->typeNode))){
             // std::cerr<<__LINE__<<std::endl;
             if(!(yystack_[2].value.as < exp_astnode* > ()->typeNode.islval)){
-                error(yylhs.location,"Error: "+yystack_[2].value.as < exp_astnode* > ()->typeNode.typeName +" is not an lval.");
+                error(yylhs.location,"Error: Tried to assign value to rvalue.");
             }
             
             
@@ -2205,25 +2205,29 @@ namespace IPL {
             if(yylhs.value.as < exp_astnode* > ()->typeNode.typeName==yystack_[0].value.as < exp_astnode* > ()->typeNode.typeName){
                 error(yylhs.location,"Invalid operand type \"" + yystack_[0].value.as < exp_astnode* > ()->typeNode.typeName +"\" of unary *");
             }
+            int nrs = yystack_[0].value.as < exp_astnode* > ()->typeNode.numptrstars + yystack_[0].value.as < exp_astnode* > ()->typeNode.arrsizes.size();
+            if(yystack_[1].value.as < std::string > ()=="DEREF"&&yystack_[0].value.as < exp_astnode* > ()->typeNode.typeName.substr(0,4)=="void"&&(nrs==1)){
+                error(yylhs.location,"Dereferenced incomplete type void*");
+            }
         }
     }
 }
-#line 2212 "parser.tab.cc"
+#line 2216 "parser.tab.cc"
     break;
 
   case 59: // multiplicative_expression: unary_expression
-#line 652 "parser.yy"
+#line 656 "parser.yy"
                                            {
     if(Symbols::symTabConstructed){   
         yylhs.value.as < op_binary_astnode* > () = (op_binary_astnode*) yystack_[0].value.as < exp_astnode* > ();
     }
 
 }
-#line 2223 "parser.tab.cc"
+#line 2227 "parser.tab.cc"
     break;
 
   case 60: // multiplicative_expression: multiplicative_expression '*' unary_expression
-#line 658 "parser.yy"
+#line 662 "parser.yy"
                                                 {
     //operator and expression match check here.
     if(Symbols::symTabConstructed){
@@ -2234,11 +2238,11 @@ namespace IPL {
         yylhs.value.as < op_binary_astnode* > () = new op_binary_astnode(op, yystack_[2].value.as < op_binary_astnode* > (), yystack_[0].value.as < exp_astnode* > ());
     }
 }
-#line 2238 "parser.tab.cc"
+#line 2242 "parser.tab.cc"
     break;
 
   case 61: // multiplicative_expression: multiplicative_expression '/' unary_expression
-#line 668 "parser.yy"
+#line 672 "parser.yy"
                                                 {
     if(Symbols::symTabConstructed){
         std::string op = "DIV?";
@@ -2248,29 +2252,38 @@ namespace IPL {
         yylhs.value.as < op_binary_astnode* > () = new op_binary_astnode(op, yystack_[2].value.as < op_binary_astnode* > (), yystack_[0].value.as < exp_astnode* > ());
     }
 }
-#line 2252 "parser.tab.cc"
+#line 2256 "parser.tab.cc"
     break;
 
   case 62: // postfix_expression: primary_expression
-#line 679 "parser.yy"
+#line 683 "parser.yy"
                                       {
     yylhs.value.as < exp_astnode* > () = yystack_[0].value.as < exp_astnode* > ();
 }
-#line 2260 "parser.tab.cc"
+#line 2264 "parser.tab.cc"
     break;
 
   case 63: // postfix_expression: postfix_expression '[' expression ']'
-#line 682 "parser.yy"
+#line 686 "parser.yy"
                                        {
-    if(Symbols::symTabConstructed){   
+    if(Symbols::symTabConstructed){
+        if(yystack_[3].value.as < exp_astnode* > ()->typeNode.typeName.substr(0,4)=="void"){
+            error(yylhs.location,"Tried to dereference an incomplete type.");
+        }
+        if(yystack_[3].value.as < exp_astnode* > ()->typeNode.numptrstars + yystack_[3].value.as < exp_astnode* > ()->typeNode.arrsizes.size()==0){
+            error(yylhs.location, "Tried to dereference a non-pointer");
+        }
+        if(yystack_[1].value.as < exp_astnode* > ()->typeNode.typeName!="int"){
+            error(yylhs.location, "Argument passed to operator[] must be of type int.");
+        }
         yylhs.value.as < exp_astnode* > () = new arrayref_astnode(yystack_[3].value.as < exp_astnode* > (), yystack_[1].value.as < exp_astnode* > ());
     }
 }
-#line 2270 "parser.tab.cc"
+#line 2283 "parser.tab.cc"
     break;
 
   case 64: // postfix_expression: IDENTIFIER '(' ')'
-#line 687 "parser.yy"
+#line 700 "parser.yy"
                     {
     if (Symbols::symTabConstructed) {
         std::string function_name = yystack_[2].value.as < std::string > ();
@@ -2297,11 +2310,11 @@ namespace IPL {
         }
     }
 }
-#line 2301 "parser.tab.cc"
+#line 2314 "parser.tab.cc"
     break;
 
   case 65: // postfix_expression: IDENTIFIER '(' expression_list ')'
-#line 713 "parser.yy"
+#line 726 "parser.yy"
                                     {
     if (Symbols::symTabConstructed) {
         std::string function_name = yystack_[3].value.as < std::string > ();
@@ -2345,13 +2358,16 @@ namespace IPL {
         }
     }
 }
-#line 2349 "parser.tab.cc"
+#line 2362 "parser.tab.cc"
     break;
 
   case 66: // postfix_expression: postfix_expression '.' IDENTIFIER
-#line 756 "parser.yy"
+#line 769 "parser.yy"
                                    {
     if(Symbols::symTabConstructed){
+        if(yystack_[2].value.as < exp_astnode* > ()->typeNode.typeName.substr(0,6)!="struct"){
+            error(yylhs.location,"LHS of . must be of type struct.");
+        }
         yylhs.value.as < exp_astnode* > () = new member_astnode(yystack_[2].value.as < exp_astnode* > (), new identifier_astnode(yystack_[0].value.as < std::string > ()));
         std::cerr<<"using this rule"<<std::endl;
         std::string structName = yystack_[2].value.as < exp_astnode* > ()->typeNode.typeName;
@@ -2366,13 +2382,16 @@ namespace IPL {
         }
     }
 }
-#line 2370 "parser.tab.cc"
+#line 2386 "parser.tab.cc"
     break;
 
   case 67: // postfix_expression: postfix_expression PTR_OP IDENTIFIER
-#line 772 "parser.yy"
+#line 788 "parser.yy"
                                       {
     if(Symbols::symTabConstructed){
+        if(yystack_[2].value.as < exp_astnode* > ()->typeNode.typeName.substr(0,6)!="struct"){
+            error(yylhs.location,"LHS of -> must be of type struct.");
+        }
         yylhs.value.as < exp_astnode* > () = new arrow_astnode(yystack_[2].value.as < exp_astnode* > (), new identifier_astnode(yystack_[0].value.as < std::string > ()));
         typespec_astnode dereftype = yystack_[2].value.as < exp_astnode* > ()->typeNode;
         dereftype.deref();
@@ -2388,24 +2407,29 @@ namespace IPL {
         }
     }
 }
-#line 2392 "parser.tab.cc"
+#line 2411 "parser.tab.cc"
     break;
 
   case 68: // postfix_expression: postfix_expression INC_OP
-#line 789 "parser.yy"
+#line 808 "parser.yy"
                            {
     if(Symbols::symTabConstructed){
-        //type checks for $1
-        
+        if(!(yystack_[1].value.as < exp_astnode* > ()->typeNode.islval)){
+            error(yylhs.location,"Postfix operator "+yystack_[0].value.as < std::string > ()+" can only be applied to lvalues.");
+        }
+        if(!(yystack_[1].value.as < exp_astnode* > ()->typeNode.isNumeric()||(yystack_[1].value.as < exp_astnode* > ()->typeNode.numptrstars>0&&yystack_[1].value.as < exp_astnode* > ()->typeNode.arrsizes.size()==0))){
+            error(yylhs.location,"Invalid data type for postfix operator "+yystack_[0].value.as < std::string > ());
+        }
         yylhs.value.as < exp_astnode* > () = new op_unary_astnode("PP",yystack_[1].value.as < exp_astnode* > ());
         yylhs.value.as < exp_astnode* > ()->typeNode = yystack_[1].value.as < exp_astnode* > ()->typeNode;
+        yylhs.value.as < exp_astnode* > ()->typeNode.islval = false;
     }
 }
-#line 2405 "parser.tab.cc"
+#line 2429 "parser.tab.cc"
     break;
 
   case 69: // primary_expression: IDENTIFIER
-#line 799 "parser.yy"
+#line 823 "parser.yy"
                               {
     if(Symbols::symTabConstructed){
         yylhs.value.as < exp_astnode* > () = new identifier_astnode(yystack_[0].value.as < std::string > ());
@@ -2422,11 +2446,11 @@ namespace IPL {
     }
     std::cerr<<"bloom"<<std::endl;
 }
-#line 2426 "parser.tab.cc"
+#line 2450 "parser.tab.cc"
     break;
 
   case 70: // primary_expression: INT_CONSTANT
-#line 815 "parser.yy"
+#line 839 "parser.yy"
               {
     if(Symbols::symTabConstructed){   
         yylhs.value.as < exp_astnode* > () = new intconst_astnode(yystack_[0].value.as < std::string > ());
@@ -2437,11 +2461,11 @@ namespace IPL {
         }
     }
 }
-#line 2441 "parser.tab.cc"
+#line 2465 "parser.tab.cc"
     break;
 
   case 71: // primary_expression: FLOAT_CONSTANT
-#line 825 "parser.yy"
+#line 849 "parser.yy"
                 {
     if(Symbols::symTabConstructed){   
         yylhs.value.as < exp_astnode* > () = new floatconst_astnode(yystack_[0].value.as < std::string > ());
@@ -2449,11 +2473,11 @@ namespace IPL {
         yylhs.value.as < exp_astnode* > ()->typeNode.islval = false;
     }
 }
-#line 2453 "parser.tab.cc"
+#line 2477 "parser.tab.cc"
     break;
 
   case 72: // primary_expression: STRING_LITERAL
-#line 832 "parser.yy"
+#line 856 "parser.yy"
                 {
     if(Symbols::symTabConstructed){   
         yylhs.value.as < exp_astnode* > () = new stringconst_astnode(yystack_[0].value.as < std::string > ());
@@ -2462,121 +2486,130 @@ namespace IPL {
         // $$->print();
     }
 }
-#line 2466 "parser.tab.cc"
+#line 2490 "parser.tab.cc"
     break;
 
   case 73: // primary_expression: '(' expression ')'
-#line 840 "parser.yy"
+#line 864 "parser.yy"
                     {
     yylhs.value.as < exp_astnode* > () = yystack_[1].value.as < exp_astnode* > ();
 }
-#line 2474 "parser.tab.cc"
+#line 2498 "parser.tab.cc"
     break;
 
   case 74: // expression_list: expression
-#line 845 "parser.yy"
+#line 869 "parser.yy"
                            {
     yylhs.value.as < std::vector<exp_astnode*> > () = std::vector<exp_astnode*>();
     yylhs.value.as < std::vector<exp_astnode*> > ().push_back(yystack_[0].value.as < exp_astnode* > ());
     // std::cerr << __LINE__ << (*($$.rbegin()))->typeNode.typeName<<std::endl;
 }
-#line 2484 "parser.tab.cc"
+#line 2508 "parser.tab.cc"
     break;
 
   case 75: // expression_list: expression_list ',' expression
-#line 850 "parser.yy"
+#line 874 "parser.yy"
                                 {
     yystack_[2].value.as < std::vector<exp_astnode*> > ().push_back(yystack_[0].value.as < exp_astnode* > ());
     yylhs.value.as < std::vector<exp_astnode*> > () = yystack_[2].value.as < std::vector<exp_astnode*> > ();
 }
-#line 2493 "parser.tab.cc"
+#line 2517 "parser.tab.cc"
     break;
 
   case 76: // unary_operator: '-'
-#line 855 "parser.yy"
+#line 879 "parser.yy"
                    {
     yylhs.value.as < std::string > () = std::string("UMINUS");
 }
-#line 2501 "parser.tab.cc"
+#line 2525 "parser.tab.cc"
     break;
 
   case 77: // unary_operator: '!'
-#line 858 "parser.yy"
+#line 882 "parser.yy"
      {
     yylhs.value.as < std::string > () = std::string("NOT");
 }
-#line 2509 "parser.tab.cc"
+#line 2533 "parser.tab.cc"
     break;
 
   case 78: // unary_operator: '&'
-#line 861 "parser.yy"
+#line 885 "parser.yy"
      {
     yylhs.value.as < std::string > () = std::string("ADDRESS");
 }
-#line 2517 "parser.tab.cc"
+#line 2541 "parser.tab.cc"
     break;
 
   case 79: // unary_operator: '*'
-#line 864 "parser.yy"
+#line 888 "parser.yy"
      {
     yylhs.value.as < std::string > () = std::string("DEREF");
 }
-#line 2525 "parser.tab.cc"
+#line 2549 "parser.tab.cc"
     break;
 
   case 80: // selection_statement: IF '(' expression ')' statement ELSE statement
-#line 869 "parser.yy"
+#line 893 "parser.yy"
                                                                    {
-    if(Symbols::symTabConstructed){   
+    if(Symbols::symTabConstructed){  
+        if(!(yystack_[4].value.as < exp_astnode* > ()->typeNode.isNumeric()||yystack_[4].value.as < exp_astnode* > ()->typeNode.getnrs()>0)){
+            error(yylhs.location,"Invalid type for condition expression in for loop");
+        }    
         yylhs.value.as < statement_astnode* > () = new if_astnode(yystack_[4].value.as < exp_astnode* > (), yystack_[2].value.as < statement_astnode* > (), yystack_[0].value.as < statement_astnode* > ());
     }
 }
-#line 2535 "parser.tab.cc"
+#line 2562 "parser.tab.cc"
     break;
 
   case 81: // iteration_statement: WHILE '(' expression ')' statement
-#line 876 "parser.yy"
+#line 903 "parser.yy"
                                                        {
     if(Symbols::symTabConstructed){   
+        if(!(yystack_[2].value.as < exp_astnode* > ()->typeNode.isNumeric()||yystack_[2].value.as < exp_astnode* > ()->typeNode.getnrs()>0)){
+            error(yylhs.location,"Invalid type for condition expression in while loop");
+        }   
         yylhs.value.as < statement_astnode* > () = new while_astnode(yystack_[2].value.as < exp_astnode* > (), yystack_[0].value.as < statement_astnode* > ());
     }
 }
-#line 2545 "parser.tab.cc"
+#line 2575 "parser.tab.cc"
     break;
 
   case 82: // iteration_statement: FOR '(' assignment_expression ';' expression ';' assignment_expression ')' statement
-#line 881 "parser.yy"
+#line 911 "parser.yy"
                                                                                       {
-    if(Symbols::symTabConstructed){   
+    if(Symbols::symTabConstructed){
+        if(!(yystack_[4].value.as < exp_astnode* > ()->typeNode.isNumeric()||yystack_[4].value.as < exp_astnode* > ()->typeNode.getnrs()>0)){
+            error(yylhs.location,"Invalid type for condition expression in for loop");
+        }   
         yylhs.value.as < statement_astnode* > () = new for_astnode(yystack_[6].value.as < assignE_astnode* > (), yystack_[4].value.as < exp_astnode* > (), yystack_[2].value.as < assignE_astnode* > (), yystack_[0].value.as < statement_astnode* > ());
     }
 }
-#line 2555 "parser.tab.cc"
+#line 2588 "parser.tab.cc"
     break;
 
   case 83: // declaration_list: declaration
-#line 888 "parser.yy"
+#line 921 "parser.yy"
                              {
 }
-#line 2562 "parser.tab.cc"
+#line 2595 "parser.tab.cc"
     break;
 
   case 84: // declaration_list: declaration_list declaration
-#line 890 "parser.yy"
+#line 923 "parser.yy"
                               {
 }
-#line 2569 "parser.tab.cc"
+#line 2602 "parser.tab.cc"
     break;
 
   case 85: // declaration: type_specifier declarator_list ';'
-#line 894 "parser.yy"
+#line 927 "parser.yy"
                                                {
 }
-#line 2576 "parser.tab.cc"
+#line 2609 "parser.tab.cc"
     break;
 
   case 86: // declarator_list: declarator
-#line 898 "parser.yy"
+#line 931 "parser.yy"
                            {
     yylhs.value.as < typespec_astnode > () = yystack_[0].value.as < typespec_astnode > ();
     // std::cerr<<$1.typeName<<" has "<<$1.numptrstars<<" stars"<<std::endl;
@@ -2592,11 +2625,11 @@ namespace IPL {
         st->rows[topvarname] = SymEntry(yystack_[0].value.as < typespec_astnode > (),SymTab::ST_HL_type::VAR,SymTab::ST_LPG::LOCAL,size,offset);
     }
 }
-#line 2596 "parser.tab.cc"
+#line 2629 "parser.tab.cc"
     break;
 
   case 87: // declarator_list: declarator_list ',' declarator
-#line 913 "parser.yy"
+#line 946 "parser.yy"
                                 {
     yylhs.value.as < typespec_astnode > () = yystack_[0].value.as < typespec_astnode > ();
     string type = yystack_[0].value.as < typespec_astnode > ().typeName;
@@ -2609,11 +2642,11 @@ namespace IPL {
         ststack.top()->rows[topvarname] = SymEntry(yystack_[0].value.as < typespec_astnode > (),SymTab::ST_HL_type::VAR,SymTab::ST_LPG::LOCAL,size,offset);
     }
 }
-#line 2613 "parser.tab.cc"
+#line 2646 "parser.tab.cc"
     break;
 
 
-#line 2617 "parser.tab.cc"
+#line 2650 "parser.tab.cc"
 
             default:
               break;
@@ -3039,10 +3072,10 @@ namespace IPL {
      289,   301,   308,   318,   321,   330,   333,   336,   340,   345,
      353,   359,   364,   369,   372,   375,   378,   381,   403,   437,
      444,   471,   516,   520,   527,   531,   538,   542,   551,   562,
-     566,   575,   584,   593,   604,   608,   617,   628,   632,   652,
-     658,   668,   679,   682,   687,   713,   756,   772,   789,   799,
-     815,   825,   832,   840,   845,   850,   855,   858,   861,   864,
-     869,   876,   881,   888,   890,   894,   898,   913
+     566,   575,   584,   593,   604,   608,   617,   628,   632,   656,
+     662,   672,   683,   686,   700,   726,   769,   788,   808,   823,
+     839,   849,   856,   864,   869,   874,   879,   882,   885,   888,
+     893,   903,   911,   921,   923,   927,   931,   946
   };
 
   void
@@ -3123,9 +3156,9 @@ namespace IPL {
 
 #line 5 "parser.yy"
 } // IPL
-#line 3127 "parser.tab.cc"
+#line 3160 "parser.tab.cc"
 
-#line 927 "parser.yy"
+#line 960 "parser.yy"
 
 //grammar definition.
 void 
diff --git a/parser.yy b/parser.yy
index c4dfcb8..9d88eb5 100644
--- a/parser.yy
+++ b/parser.yy
@@ -407,7 +407,7 @@ assignment_expression: unary_expression '=' expression{
         if(($1->typeNode.compatibleWith($3->typeNode))){
             // std::cerr<<__LINE__<<std::endl;
             if(!($1->typeNode.islval)){
-                error(@$,"Error: "+$1->typeNode.typeName +" is not an lval.");
+                error(@$,"Error: Tried to assign value to rvalue.");
             }
             
             
@@ -644,6 +644,10 @@ unary_expression: postfix_expression{
             if($$->typeNode.typeName==$2->typeNode.typeName){
                 error(@$,"Invalid operand type \"" + $2->typeNode.typeName +"\" of unary *");
             }
+            int nrs = $2->typeNode.numptrstars + $2->typeNode.arrsizes.size();
+            if($1=="DEREF"&&$2->typeNode.typeName.substr(0,4)=="void"&&(nrs==1)){
+                error(@$,"Dereferenced incomplete type void*");
+            }
         }
     }
 }
@@ -680,7 +684,16 @@ postfix_expression: primary_expression{
     $$ = $1;
 }
 | postfix_expression '[' expression ']'{
-    if(Symbols::symTabConstructed){   
+    if(Symbols::symTabConstructed){
+        if($1->typeNode.typeName.substr(0,4)=="void"){
+            error(@$,"Tried to dereference an incomplete type.");
+        }
+        if($1->typeNode.numptrstars + $1->typeNode.arrsizes.size()==0){
+            error(@$, "Tried to dereference a non-pointer");
+        }
+        if($3->typeNode.typeName!="int"){
+            error(@$, "Argument passed to operator[] must be of type int.");
+        }
         $$ = new arrayref_astnode($1, $3);
     }
 }
@@ -755,6 +768,9 @@ postfix_expression: primary_expression{
 }
 | postfix_expression '.' IDENTIFIER{
     if(Symbols::symTabConstructed){
+        if($1->typeNode.typeName.substr(0,6)!="struct"){
+            error(@$,"LHS of . must be of type struct.");
+        }
         $$ = new member_astnode($1, new identifier_astnode($3));
         std::cerr<<"using this rule"<<std::endl;
         std::string structName = $1->typeNode.typeName;
@@ -771,6 +787,9 @@ postfix_expression: primary_expression{
 }
 | postfix_expression PTR_OP IDENTIFIER{
     if(Symbols::symTabConstructed){
+        if($1->typeNode.typeName.substr(0,6)!="struct"){
+            error(@$,"LHS of -> must be of type struct.");
+        }
         $$ = new arrow_astnode($1, new identifier_astnode($3));
         typespec_astnode dereftype = $1->typeNode;
         dereftype.deref();
@@ -788,10 +807,15 @@ postfix_expression: primary_expression{
 }
 | postfix_expression INC_OP{
     if(Symbols::symTabConstructed){
-        //type checks for $1
-        
+        if(!($1->typeNode.islval)){
+            error(@$,"Postfix operator "+$2+" can only be applied to lvalues.");
+        }
+        if(!($1->typeNode.isNumeric()||($1->typeNode.numptrstars>0&&$1->typeNode.arrsizes.size()==0))){
+            error(@$,"Invalid data type for postfix operator "+$2);
+        }
         $$ = new op_unary_astnode("PP",$1);
         $$->typeNode = $1->typeNode;
+        $$->typeNode.islval = false;
     }
 }
 ;
@@ -867,7 +891,10 @@ unary_operator: '-'{
 ;
 
 selection_statement: IF '(' expression ')' statement ELSE statement{
-    if(Symbols::symTabConstructed){   
+    if(Symbols::symTabConstructed){  
+        if(!($3->typeNode.isNumeric()||$3->typeNode.getnrs()>0)){
+            error(@$,"Invalid type for condition expression in for loop");
+        }    
         $$ = new if_astnode($3, $5, $7);
     }
 }
@@ -875,11 +902,17 @@ selection_statement: IF '(' expression ')' statement ELSE statement{
 
 iteration_statement: WHILE '(' expression ')' statement{
     if(Symbols::symTabConstructed){   
+        if(!($3->typeNode.isNumeric()||$3->typeNode.getnrs()>0)){
+            error(@$,"Invalid type for condition expression in while loop");
+        }   
         $$ = new while_astnode($3, $5);
     }
 }
 | FOR '(' assignment_expression ';' expression ';' assignment_expression ')' statement{
-    if(Symbols::symTabConstructed){   
+    if(Symbols::symTabConstructed){
+        if(!($5->typeNode.isNumeric()||$5->typeNode.getnrs()>0)){
+            error(@$,"Invalid type for condition expression in for loop");
+        }   
         $$ = new for_astnode($3, $5, $7, $9);
     }
 }
diff --git a/symtab.cpp b/symtab.cpp
index 67a9a59..1637d94 100644
--- a/symtab.cpp
+++ b/symtab.cpp
@@ -212,7 +212,10 @@ void Symbols::initGST(){
         "OR_OP","AND_OP",
     };
     op_binary_astnode::boolgens={
-        "LE_OP?","GE_OP?","GT_OP?","LT_OP?","NE_OP?","EQ_OP?"
+        "LE_OP?","GE_OP?","GT_OP?","LT_OP?"
+    };
+    op_binary_astnode::boolgenseq={
+        "NE_OP?","EQ_OP?"
     };
     typespec_astnode::voidc.baseTypeName = "void";
     typespec_astnode::voidc.baseTypeWidth = 0;
